%{
#include <stdio.h>
#include "util.h"
#include "errormsg.h"

#define YYDEBUG 1

int yylex(void);

void yyerror(char *s)
{
	EM_error(EM_tokPos, "%s", s);
}

int yydebug = 1;

%}

%union {
	int pos;
	int ival;
	string sval;
}

%token <sval> ID STRING
%token <ival> INT

%token
	COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK
	LBRACE RBRACE DOT
	PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE
	AND OR ASSIGN
	ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF
	BREAK NIL
	FUNCTION VAR TYPE

%left SEMICOLON
%left TIMES DIVIDE
%nonassoc EQ NEQ LT LE GT GE
%left AND OR
%left PLUS MINUS
%nonassoc THEN
%nonassoc ELSE

%start program

%%

program
	: expression                     { absyn_root = $1; }

atom
	: INT                            { $$ = A_IntExp(EM_tokPos, $1); }
	| MINUS atom                     { $$ = A_OpExp(EM_tokPos, A_minusOp, A_IntExp(Em_tokPos, 0), A_IntExp(EM_tokPos, $2)); }
	| NIL                            { $$ = A_NilExp(EM_tokPos); }
	| STRING                         { $$ = A_StringExp(EM_tokPos, $1); }
	| BREAK                          { $$ = A_BreakExp(EM_tokPos); }
	| LPAREN RPAREN
	| lvalue_expression              { $$ = $1; }
	| LPAREN expression_seq RPAREN   { $$ = $2; }
	| LPAREN expression RPAREN       { $$ = $2; }
	| ID LPAREN RPAREN               { $$ = A_CallExp(EM_tokPos, S_Symbol($1), A_ExpList(NULL, NULL)); }
	| ID LPAREN argument_list RPAREN { $$ = A_CAllExp(EM_tokPos, S_Symbol($1), $3); }
	;

expression
	: atom                           { $$ = $1; }
	| binop_expression               { $$ = $1; }
	| make_array_expression          { $$ = $1; }
	| make_record_expression         { $$ = $1; }
	| let_declaration                { $$ = $1; }
	| for_expression                 { $$ = $1; }
	| while_expression               { $$ = $1; }
	| if_then_expression             { $$ = $1; }
	| if_then_else_expression        { $$ = $1; }
	| lvalue_assignment              { $$ = $1; }
	;

binop_expression
	: atom PLUS expression           { $$ = A_OpExp(EM_tokPos, A_plusOp, $1, $2); }
	| atom MINUS expression          { $$ = A_OpExp(EM_tokPos, A_minusOp, $1, $2); }
	| atom TIMES expression          { $$ = A_OpExp(EM_tokPos, A_timesOp, $1, $2); }
	| atom DIVIDE expression         { $$ = A_OpExp(EM_tokPos, A_divideOp, $1, $2); }
	| atom EQ expression             { $$ = A_OpExp(EM_tokPos, A_eqOp, $1, $2); }
	| atom NEQ expression            { $$ = A_OpExp(EM_tokPos, A_neqOp, $1, $2); }
	| atom LT expression             { $$ = A_OpExp(EM_tokPos, A_ltOp, $1, $2); }
	| atom LE expression             { $$ = A_OpExp(EM_tokPos, A_leOp, $1, $2); }
	| atom GT expression             { $$ = A_OpExp(EM_tokPos, A_gtOp, $1, $2); }
	| atom GE expression             { $$ = A_OpExp(EM_tokPos, A_geOp, $1, $2); }
	| atom AND expression
	| atom OR expression
	;

make_array_expression
	: lvalue_expression OF expression
	;

make_record_expression
	: ID LBRACE RBRACE
	| ID LBRACE assignment_list RBRACE
	;

assignment_list
	: ID EQ expression
	| assignment_list COMMA ID EQ expression
	;

argument_list
	: expression
	| argument_list COMMA expression
	;

expression_seq
	: expression SEMICOLON expression
	| expression_seq SEMICOLON expression
	;

let_declaration
	: LET declarations IN expression_kleenes END
	;

expression_kleenes
	: expression
	| expression_seq
	|
	;

declarations
	: declaration
	| declarations declaration
	;

declaration
	: type_declaration
	| var_declaration
	| func_declaration
	;

type_declaration
	: TYPE ID EQ type
	;

type
	: ID
	| LBRACE type_fields RBRACE
	| ARRAY OF ID
	;

type_fields
	: ID COLON ID
	| type_fields COMMA ID COLON ID
	;

lvalue_expression
	: ID
	| lvalue_expression DOT ID
	| lvalue_expression LBRACK expression RBRACK
	;

lvalue_assignment
	: lvalue_expression ASSIGN expression
	;

var_declaration
	: VAR ID ASSIGN expression
	| VAR ID COLON ID ASSIGN expression
	;

func_declaration
	: FUNCTION ID LPAREN RPAREN EQ expression
	| FUNCTION ID LPAREN RPAREN COLON ID EQ expression
	| FUNCTION ID LPAREN type_fields RPAREN EQ expression
	| FUNCTION ID LPAREN type_fields RPAREN COLON ID EQ expression
	;

for_expression
	: FOR ID ASSIGN expression TO expression DO expression
	;

while_expression
	: WHILE expression DO expression
	;

if_then_expression
	: IF expression THEN expression
	;

if_then_else_expression
	: IF expression THEN expression ELSE expression
	;
